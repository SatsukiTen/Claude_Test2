# ブロック崩し (Block Breaker) — 詳細設計書

> **目的**: 本ドキュメントをAIにinputすることで、同等のAndroidアプリを実装できることを目指す。

---

## 1. アーキテクチャ概要

```
┌─────────────────────────────────────────────────┐
│  MainActivity (AppCompatActivity)               │
│    - SoundManager を生成・管理                   │
│    - GameView を生成・setContentView             │
│    - onPause/onResume でライフサイクル連携        │
│                                                 │
│    ┌──────────────────────────────────────────┐ │
│    │  GameView (SurfaceView + Runnable)       │ │
│    │    - ゲームループ (60fps) をスレッドで実行  │ │
│    │    - Canvas直接描画                       │ │
│    │    - タッチイベント処理                    │ │
│    │    - GameState ステートマシン              │ │
│    └──────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  SettingsActivity (AppCompatActivity)           │
│    - XML Layoutで設定UI                          │
│    - GameSettings を通じてSharedPreferences読み書き│
└─────────────────────────────────────────────────┘

┌──────────────────┐   ┌──────────────────────────┐
│  SoundManager    │   │  GameSettings (object)   │
│    - PCM合成      │   │    - SharedPreferences   │
│    - SoundPool   │   │    - 定数定義             │
│    - AudioTrack  │   └──────────────────────────┘
└──────────────────┘

データクラス: Ball / Paddle / Block
```

---

## 2. ファイル構成

```
breakout-android/
├── app/
│   ├── build.gradle.kts
│   └── src/main/
│       ├── AndroidManifest.xml
│       ├── java/com/example/blockbreaker/
│       │   ├── MainActivity.kt          # エントリポイント
│       │   ├── GameView.kt              # ゲームエンジン（メイン）
│       │   ├── SoundManager.kt          # 音声生成・再生
│       │   ├── GameSettings.kt          # 設定の永続化
│       │   ├── SettingsActivity.kt      # デバッグ設定画面
│       │   ├── Ball.kt                  # ボールデータクラス
│       │   ├── Paddle.kt               # パドルデータクラス
│       │   └── Block.kt                # ブロックデータクラス
│       └── res/
│           ├── layout/
│           │   └── activity_settings.xml  # 設定画面レイアウト
│           └── values/
│               ├── strings.xml
│               └── colors.xml
├── docs/
│   ├── 01_仕様書.md
│   └── 02_設計書.md
└── gradle/
```

---

## 3. クラス設計

### 3.1 MainActivity

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var soundManager: SoundManager
    private lateinit var gameView: GameView

    override fun onCreate(savedInstanceState: Bundle?)
    override fun onPause()    // soundManager.pauseBgm() + gameView.pause()
    override fun onResume()   // gameView.reloadSettings() + gameView.resume()
    override fun onDestroy()  // soundManager.release()
}
```

**onCreate 処理順序**:
1. フルスクリーンフラグ設定 (`FLAG_FULLSCREEN`, `FLAG_KEEP_SCREEN_ON`)
2. 縦向き固定 (`SCREEN_ORIENTATION_PORTRAIT`)
3. `SoundManager` 生成 → `init()` 呼び出し（バックグラウンドでPCM合成）
4. `GameView` 生成（`soundManager` を渡す）
5. `setContentView(gameView)`

---

### 3.2 GameView

```kotlin
class GameView(
    context: Context,
    attrs: AttributeSet? = null,
    private val soundManager: SoundManager? = null
) : SurfaceView(context, attrs), Runnable, SurfaceHolder.Callback
```

#### フィールド一覧

| フィールド | 型 | 説明 |
|---|---|---|
| `gameThread` | `Thread?` | ゲームループスレッド |
| `isRunning` | `@Volatile Boolean` | スレッド継続フラグ |
| `screenW`, `screenH` | `Float` | 画面サイズ（`surfaceChanged`で設定） |
| `cfgBallSpeed` | `Float` | 設定値：ボール速度比率 |
| `cfgMaxSpeedMult` | `Float` | 設定値：最大速度倍率 |
| `cfgPaddleBase` | `Float` | 設定値：パドル基本幅% |
| `cfgPaddleShrink` | `Float` | 設定値：ステージ毎縮小% |
| `ball` | `Ball` | ボールオブジェクト |
| `paddle` | `Paddle` | パドルオブジェクト |
| `blocks` | `MutableList<Block>` | ブロックリスト |
| `ballSpeed` | `Float` | 現在のボール速度スカラー |
| `totalBlocks` | `Int` | ステージ開始時の全ブロック数 |
| `currentPitchRate` | `Float` | SE ピッチレート（1.0〜1.5） |
| `gameState` | `GameState` | 現在のゲーム状態 |
| `score` | `Int` | 現在スコア |
| `lives` | `Int` | 残機数 |
| `stage` | `Int` | 現在ステージ（1〜10） |
| `maxStage` | `Int` | = 10 (定数) |
| `pauseButtonTouched` | `Boolean` | ポーズボタン押下トラッキング |

#### GameState 列挙型

```kotlin
enum class GameState {
    STAGE_SELECT,  // ステージ選択画面
    WAITING,       // ゲーム待機（ボール停止、タップ待ち）
    PLAYING,       // ゲームプレイ中
    PAUSED,        // ポーズ中
    STAGE_CLEAR,   // ステージクリア
    GAME_OVER,     // ゲームオーバー
    WIN            // オールクリア
}
```

#### 主要メソッド

| メソッド | 説明 |
|---|---|
| `reloadSettings()` | `GameSettings.load()` を呼び cfgXxx を更新 |
| `pause()` | `isRunning=false`、スレッドをinterrupt/join(2000ms) |
| `resume()` | `isRunning=true`、新スレッド起動。`screenW==0f` なら何もしない |
| `baseBallSpeed()` | `screenW × cfgBallSpeed` |
| `paddleWidthForStage()` | `screenW × ((cfgPaddleBase - (stage-1)×cfgPaddleShrink) / 100)`、最小 screenW×0.10 |
| `initToSelectScreen()` | score/lives/stage初期化、BGM停止、`STAGE_SELECT`状態へ |
| `startStage()` | パドル・ボール・ブロック初期化、`WAITING`状態へ |
| `setupBlocks()` | `stagePatterns` からブロックリストを生成 |
| `run()` | ゲームループ（60fps固定） |
| `update()` | `PLAYING`状態のみ物理計算 |
| `renderFrame()` | `lockCanvas → drawScene → unlockCanvasAndPost` |
| `movePaddle(x)` | `paddle.x = (x - paddle.width/2).coerceIn(0, screenW-paddle.width)` |

---

### 3.3 データクラス

```kotlin
data class Ball(
    var x: Float,
    var y: Float,
    var radius: Float = 20f,
    var speedX: Float = 0f,
    var speedY: Float = 0f
)

data class Paddle(
    var x: Float,
    var y: Float,
    var width: Float = 200f,
    var height: Float = 30f
)

data class Block(
    val x: Float,
    val y: Float,
    val width: Float,
    val height: Float,
    val color: Int,
    var isAlive: Boolean = true
)
```

---

### 3.4 GameSettings

```kotlin
object GameSettings {
    private const val PREFS_NAME = "blockbreaker_settings"

    // キー定数
    const val KEY_BALL_SPEED    = "ball_speed"
    const val KEY_MAX_SPEED     = "max_speed_mult"
    const val KEY_PADDLE_BASE   = "paddle_base"
    const val KEY_PADDLE_SHRINK = "paddle_shrink"

    // デフォルト値
    const val DEF_BALL_SPEED    = 0.015f
    const val DEF_MAX_SPEED     = 4.0f
    const val DEF_PADDLE_BASE   = 28f
    const val DEF_PADDLE_SHRINK = 1.6f

    // 範囲
    const val MIN_BALL_SPEED    = 0.005f; const val MAX_BALL_SPEED    = 0.030f
    const val MIN_MAX_SPEED     = 1.0f;  const val MAX_MAX_SPEED     = 8.0f
    const val MIN_PADDLE_BASE   = 10f;   const val MAX_PADDLE_BASE   = 45f
    const val MIN_PADDLE_SHRINK = 0f;    const val MAX_PADDLE_SHRINK = 4.0f

    fun load(context: Context): FloatArray   // [ballSpeed, maxSpeed, paddleBase, paddleShrink]
    fun save(context: Context, values: FloatArray)
    fun reset(context: Context)              // save with DEF_* values
}
```

---

### 3.5 SettingsActivity

```kotlin
class SettingsActivity : AppCompatActivity() {
    private val paramLabels = listOf(...)  // 表示名 × 4
    private val paramMins   = floatArrayOf(...)
    private val paramMaxs   = floatArrayOf(...)
    private lateinit var seekBars: List<SeekBar>    // seekBallSpeed, seekMaxSpeed, seekPaddleBase, seekPaddleShrink
    private lateinit var labelViews: List<TextView>  // labelBallSpeed, ...
    private val currentValues = FloatArray(4)

    override fun onCreate(...)   // SeekBar初期化、リスナー設定
    override fun onStop(...)     // GameSettings.save() 呼び出し

    // SeekBar progress (0-1000) ↔ Float 変換
    private fun toProgress(i, v): Int  = ((v - min) / (max - min) * 1000).toInt()
    private fun toValue(i, p): Float   = min + p / 1000f * (max - min)
    private fun updateLabel(i)         // "名前:  値単位" 形式でTextViewを更新
}
```

---

### 3.6 SoundManager

```kotlin
class SoundManager(private val context: Context) {
    enum class SfxId { WALL_HIT, PADDLE_HIT, BLOCK_HIT, LIFE_LOST, GAME_OVER, WIN }

    private val sampleRate = 44100

    fun init()                           // バックグラウンドスレッドでPCM合成・初期化
    fun playSfx(id: SfxId, rate: Float = 1f)  // rate: 0.5〜2.0
    fun pauseBgm()
    fun resumeBgm()
    fun release()                        // AudioTrack/SoundPool解放、tempFile削除
}
```

**PCM合成式（単音）**:
```
n = durationSec × sampleRate
attackSamples = 0.005 × sampleRate  (5ms)
for i in 0..n:
    t = i / sampleRate
    envAttack = if (i < attackSamples) i/attackSamples else 1.0
    v = envAttack × 0.8 × sin(2π × freq × t) × exp(-t / tau)
    pcm[i] = (v × Short.MAX_VALUE).toShort()
```

**BGM合成**: 上記単音を16拍分（拍=60/BPM秒）合算。null拍は無音。振幅0.35、τ=0.8s。

**SFX読み込みフロー**:
1. PCM配列 → WAV（44バイトヘッダ + PCMデータ）としてByteArray生成
2. `context.cacheDir` に一時ファイル保存
3. `SoundPool.load(path, 1)` でロード
4. SoundManagerインスタンス内で一時ファイルリストを管理し、`release()` 時に削除

---

## 4. ゲームループ設計

```
Thread.run() {
    while (isRunning) {
        t0 = currentTimeMillis()
        update()       // 物理演算（PLAYINGのみ）
        renderFrame()  // Canvas描画（全状態）
        sleep = 16ms - (currentTimeMillis() - t0)
        if (sleep > 0) Thread.sleep(sleep)
    }
}
```

- `msPerFrame = 1000 / 60 = 16ms`
- `update()` は `gameState != PLAYING` の場合即return
- `renderFrame()` は `holder.lockCanvas()` が null の場合スキップ

---

## 5. 衝突判定アルゴリズム

### 5.1 壁との衝突

```kotlin
// 左壁
if (ball.x - ball.radius < 0) {
    ball.x = ball.radius
    ball.speedX = abs(ball.speedX)  // 正方向に反転
}
// 右壁
if (ball.x + ball.radius > screenW) {
    ball.x = screenW - ball.radius
    ball.speedX = -abs(ball.speedX)  // 負方向に反転
}
// 上壁
if (ball.y - ball.radius < 0) {
    ball.y = ball.radius
    ball.speedY = abs(ball.speedY)  // 下方向に反転
}
// 下端（ボール消失）
if (ball.y - ball.radius > screenH) { lives--; ... }
```

### 5.2 パドルとの衝突

条件（全て満たす場合に衝突）:
1. `ball.speedY > 0`（下向き移動中）
2. `ball.y + radius >= paddle.y`
3. `ball.y - radius <= paddle.y + paddle.height`
4. `ball.x + radius >= paddle.x`
5. `ball.x - radius <= paddle.x + paddle.width`

処理:
```kotlin
ball.y = paddle.y - ball.radius  // めり込み補正
ball.speedY = -abs(ball.speedY)  // Y反転
ball.speedX = ballSpeed × ((ball.x - paddle.x) / paddle.width × 2 - 1)
```

### 5.3 ブロックとの衝突（AABB + 最小オーバーラップ法）

```kotlin
fun blockHitAxis(b: Block): Char? {
    // ブロックに最も近い点を求める
    val nearX = ball.x.coerceIn(b.x, b.x + b.width)
    val nearY = ball.y.coerceIn(b.y, b.y + b.height)
    val dx = ball.x - nearX
    val dy = ball.y - nearY

    // 距離 > 半径なら衝突なし
    if (dx*dx + dy*dy > ball.radius * ball.radius) return null

    // X/Y どちらのオーバーラップが小さいかで反射軸を決定
    val ox = min((ball.x+radius)-b.x, (b.x+b.width)-(ball.x-radius))
    val oy = min((ball.y+radius)-b.y, (b.y+b.height)-(ball.y-radius))
    return if (ox < oy) 'x' else 'y'
}
```

**1フレームでの複数衝突処理**:
- 同一フレームでX軸反射は1回のみ、Y軸反射は1回のみ
- 全ブロックをループし、衝突したブロックを全て isAlive=false に
- chain カウントを増やしスコア加算: `score += chain × 10`

---

## 6. 座標系・レイアウト設計

全座標は画面の実ピクセル（Float）。サイズはすべて `screenW` / `screenH` に対する比率で定義し、解像度非依存を実現。

### 6.1 ゲームエリアレイアウト

```
 0%  ┌─────────────────────────────┐
     │  Score    Lives    [⏸]      │
 6%  │  Stage X / 10               │
10%  ├─────────────────────────────┤
15%  │  ブロックエリア上端           │
     │  [Row0: 赤] × 8             │
     │  [Row1: 橙] × 8             │
     │  [Row2: 黄] × 8             │
     │  [Row3: 緑] × 8             │
     │  [Row4: 青] × 8             │
     │                             │
     │       ●  (ボール)           │
     │                             │
85%  │  ════════  (パドル)         │
     │                             │
100% └─────────────────────────────┘
```

### 6.2 ボタン座標まとめ（画面比率）

| ボタン | Left | Top | Right | Bottom |
|---|---|---|---|---|
| ポーズボタン⏸ | 0.83W | 0.008H | 0.98W | 0.065H |
| RESUMEボタン | 0.15W | 0.42H | 0.85W | 0.505H |
| DEBUG SETTINGSボタン | 0.15W | 0.535H | 0.85W | 0.620H |
| STAGE SELECTボタン | 0.15W | 0.650H | 0.85W | 0.735H |
| ステージボタン(各) | グリッド計算 | 0.28H〜 | グリッド計算 | 〜 |

---

## 7. スレッドモデル

```
メインスレッド (UIスレッド)
├── onCreate / onPause / onResume / onDestroy
├── onTouchEvent
└── SurfaceHolder.Callback (surfaceCreated/Changed/Destroyed)

ゲームループスレッド (GameView.gameThread)
├── update() - 物理演算
└── renderFrame() - Canvas描画
    ※ holder.lockCanvas() / unlockCanvasAndPost() はスレッドセーフ

SoundManager初期化スレッド (daemon thread)
└── initSoundPool() + initBgm() - PCM合成は重いため非同期

AudioTrack再生
└── BGMは AudioTrack の内部スレッドが再生
```

**スレッドセーフティ**:
- `isRunning`: `@Volatile` で可視性保証
- `gameState`: `@Volatile` で可視性保証
- `soundPool`, `audioTrack`: `@Volatile` で可視性保証
- `SoundManager.sfxIds`: `ConcurrentHashMap` 使用
- `SoundManager.tempFiles`: `synchronized(tempFiles)` で保護

---

## 8. AndroidManifest.xml

```xml
<manifest xmlns:android="...">
    <application
        android:allowBackup="true"
        android:label="@string/app_name"
        android:theme="@style/Theme.AppCompat.Light.NoActionBar">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait"
            android:configChanges="orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name=".SettingsActivity"
            android:exported="false"
            android:screenOrientation="portrait"
            android:configChanges="orientation|screenSize"
            android:theme="@style/Theme.AppCompat.Light.NoActionBar" />

    </application>
</manifest>
```

---

## 9. activity_settings.xml レイアウト構造

```xml
ScrollView (background="#111111", fillViewport=true)
└── LinearLayout (vertical, padding=24dp)
    ├── TextView "SETTINGS" (26sp, bold, center, paddingTop=16dp, paddingBottom=32dp)
    │
    ├── TextView @id/labelBallSpeed      (15sp, white)
    ├── TextView description             (12sp, #888888)
    ├── SeekBar  @id/seekBallSpeed       (max=1000, progressTint=#4C9EE8, thumbTint=#FFFFFF)
    │
    ├── TextView @id/labelMaxSpeed
    ├── TextView description
    ├── SeekBar  @id/seekMaxSpeed
    │
    ├── TextView @id/labelPaddleBase
    ├── TextView description
    ├── SeekBar  @id/seekPaddleBase
    │
    ├── TextView @id/labelPaddleShrink
    ├── TextView description
    ├── SeekBar  @id/seekPaddleShrink    (layout_marginBottom=40dp)
    │
    └── LinearLayout (horizontal)
        ├── Button @id/btnReset   "デフォルトに戻す" (backgroundTint=#6B2020, weight=1)
        ├── Space (16dp)
        └── Button @id/btnBack   "← 戻る"          (backgroundTint=#1E2040, weight=1)
```

**SeekBar値の変換式**:
```
// Float → progress (0-1000)
progress = ((value - min) / (max - min) * 1000).toInt().coerceIn(0, 1000)

// progress → Float
value = min + progress / 1000f * (max - min)
```

---

## 10. build.gradle.kts

```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.example.blockbreaker"
    compileSdk = 34
    defaultConfig {
        applicationId = "com.example.blockbreaker"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions { jvmTarget = "1.8" }
}

dependencies {
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("androidx.core:core-ktx:1.12.0")
}
```

---

## 11. res/values/

### strings.xml
```xml
<resources>
    <string name="app_name">Block Breaker</string>
</resources>
```

### colors.xml
```xml
<resources>
    <color name="bg">#FF000000</color>
    <color name="paddle">#FF64C8FF</color>
    <color name="ball">#FFFFFFFF</color>
</resources>
```

---

## 12. 実装上の注意点

### 12.1 ゲームループスレッドの安全な停止

`pause()` では `isRunning=false` 後にスレッドを `interrupt()` + `join(2000ms)` で待機。
`surfaceDestroyed` → `pause()` の呼び出しチェーンで、surface破棄前にスレッドが確実に終了する。

### 12.2 SurfaceView と Activity ライフサイクルの関係

- `surfaceChanged` は画面回転やバックグラウンドから復帰時にも呼ばれる
- `initToSelectScreen()` を毎回呼ぶことでゲームを安全な初期状態にリセット
- `resume()` 内の `screenW == 0f` ガードにより、surface準備前のスレッド起動を防ぐ

### 12.3 ポーズボタンとパドル操作の競合防止

`pauseButtonTouched` フラグを使い、ACTION_DOWN でポーズボタン領域に触れた場合はパドル操作を一切行わない。ACTION_UP まで一貫してフラグを維持する。

### 12.4 SoundManager の初期化タイミング

PCM合成（特にBGMの~13秒分）は重いため、daemonスレッドで非同期実行。
`playSfx()` は `sfxIds[id] ?: return` のnullガードで初期化完了前の呼び出しを安全に無視。

### 12.5 WAV一時ファイル

`SoundPool.load()` はストリームよりもファイルパスの方が確実に動作するため、
PCM → WAVファイル → `cacheDir` 保存 → `SoundPool.load(path)` のフローを採用。
`release()` 時に全tempFileを削除する。

### 12.6 描画パフォーマンス

全Paintオブジェクトはフィールドとして事前生成し、フレームごとのオブジェクト生成を回避。
ブロック描画は `isAlive` チェックのみでスキップ（リストから削除しない）。

### 12.7 ボールのめり込み防止

各壁・パドル衝突後に座標を境界値にクランプすることで、速度が大きい場合のめり込みを防ぐ。
ブロック衝突では AABB 最近接点法を使用し、重複反射を `reflX` / `reflY` フラグで防ぐ。
